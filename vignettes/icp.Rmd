---
title: "ICP"
author: "Anna Laksafoss"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(ICPSurv)
```


<span style="color:red">
  As this is just a draft of a package at the moment it will have to be built, 
  installed and attached or at the very least all code must be loaded. If the 
  project has been opened via the ICPSurv.Rproj then **Ctrl + Shift + B** will 
  build, install and attache the package and **Ctrl + Shift + L** will load all 
  the code in the R/ directory. 
</span>


This vignette gives a few example of how to use the package. The central 
function of the package is the **ICP** function. The **ICP** function takes a 
response variable **Y**, a matrix or data frame of predictors **X** and possible
a vector of environment data, **E**, and uses invariant causal prediction to find 
causal predictors of **Y** among **X**. 


## Creating a method object

When applying invariant causal 
prediction to data we must specify a test for the null hypothesis for 
$S\subseteq \{X_1, ..., X_d\}$ 

$H_{0,S}: S \text{ is an invaiant set w.r.t. } (X,Y).$

The current version of the package has implemented the following tests for the 
null hypothesis

* **CRellipsoid**:

    This method requires environment data.
  
    For each environment we regress **Y** on **X_S** and check if the confidence 
    regions (ellipses) have an overlap. If there is an overlap the null 
    hypothesis is accepted.
  
* **CRrectangle**:

    This method requires environment data.
  
    For each environment we regress **Y** on **X_S** and check if the marginal 
    confidence intervals have an overlap. If there is an overlap the null 
    hypothesis is accepted.
  
* **EnvirIrrel**:

    This method requires environment data.
  
    We regress **Y** on (**X_S**, **E**), where **E** is the environment data,
    and check if the regression parameter for **E** is significant. If the 
    regression parameter of **E** is not significant we accept the null 
    hypothesis. 
  
* **ConstRegParam**: <span style="color:red"> This is a stupid name.... </span>
    
    This method is only implemented for cox and aalen model. 
  
    We regress **Y** on **X** in a way that allowes for time dependent 
    regression parameters and ask if the fitted non-parametric regression 
    parameter functions are significantly different form a constant function. If 
    the regression parameter is not significantly different from a constant 
    function we accept the null hypothesis.
  
As can be seen from the above description of the methods it is also necissary to 
specify a regression method. All glm regressions, cox regression and aalen 
regression have all been tested in this framework. Other regression methods 
should work if passed correctly to the internal fitting function. 

All of this information is passed to the **ICP** function in the form of a list 
specifying the regression method, and the class of the list described the wanted 
hypotesis test. <span style="color:red"> Maybe we should do this in an other way
</span> So if we want to use the **EnvirIrrel** method with cox regression we 
can create a method object which can be passed to the **ICP** function in the 
following way.

```{r}
model <- list(model = "coxph")
class(model) <- "EnvirIrrel"
```

If we however want to use the **CRellipsoid** method with a poisson regression 
we may use the below code for creating a method object. 

```{r}
model <- list(model = "glm", family = "poisson")
class(model) <- "CRellipsoid"
```


## Plausible predicor test


## The **ICP** function

Now that we can create a method object we can use the **ICP** function. The 
function takes the following arguments

* **Y**: an object describing the response variable. **Y** will be passed to the
    **plausible_predictor_test** for analyzing.

* **X**: a matrix, data.frame or vector describing the covariates.

* **E**: a vector describing the environments.

* **model**: a method object. A method object is a list describing the 
    regression model, and the list has class equal to the name of the method 
    that should be invoked by the generic function **plausible_predictor_test**.

* **level**: numerical value between 0 and 1 denoting the significance level 
    used when testing. If not specified the algirithm will not return an 
    estimated set of identified causal predictors at level **level**.

* **fullAnalysis**: If **FALSE** those **plausible_predictor_test** that find 
    p-values based on iterative test only test the hypothesis at the specified 
    **level**. Hence **level** must be specified if **fullAnalysis** is set to 
    **FALSE**.
    
    The inbuilt **plausible_predictor_test** for the **CRrectangle** and 
    **CRellipsoid** method are both example of tests, that find the p-values 
    using iterative tests. So if one of these methods is used, setting 
    **fullAnalysis** to **FALSE** will save computational time. This does 
    however also mean that it is not possible to estimate the p-values of the 
    individual variables. 

* **maxNoVariables**: The maximal number of variables in the tested subsets of 
    **X**. A smaller number saves computational time.

* **stopIfEmpty**: If **TRUE** the procedure will stop if the null hypothesis 
    for the empty set has been accepted. Setting to **TRUE** will save 
    computational time in these cases, but means that an analysis of other 
    subsets of **X** is lost.
    
* **...**: additional arguments carried to the **plausibel_predicor_test**.


```{r}
#ICP(Y, X, E, model, level, fullAnalysis, maxNoVariables, stopIfEmpty)
```


## Generating data with the buit in **sim_from_adj** function

<span style="color:red">
    Should this function be removed if when putting the package on CRAN?
</span>







## Examples of use



### Linear model

```{r}
set.seed(123)
n <- 500
nam <- c("E", "X1", "X2", "X3", "Y")
G <- matrix(c(0,1,1,1,0,
              0,0,0,0,1,
              0,0,0,0,1,
              0,0,0,0,0,
              0,0,0,0,0), ncol = 5, byrow = T, dimnames = list(nam, nam))
sim <- c("sample(c(0,5,10),N, replace = T)", "rnorm(N,BETA,1)")
data <- sim_from_adj(G, n, sim)
summary(data)
```



```{r}
# Analysis using the Environment Irrelevence test
model <- list(model = "glm", family = "gaussian")
class(model) <- "EnvirIrrel"
ICP(data$Y, data[,c("X1", "X2", "X3")], data$E, model = model, level = 0.05)
```


```{r}
# Analysis using the old overlapping confidence rectangles test
class(model) <- "CRrectangle"
ICP(data$Y, data[,c("X1", "X2", "X3")], data$E, model = model, level = 0.05)
```

```{r}
# Analysis using the new confidence regions test
class(model) <- "CRellipsoid"
ICP(data$Y, data[,c("X1", "X2","X3")], data$E, model = model, level = 0.05)
```



### Poisson regression

```{r}
n <- 500
nam <- c("E", "X1", "X2", "X3", "Y")
G <- matrix(c(0,1,1,1,0,
              0,0,0,0,0.2,
              0,0,0,0,0.2,
              0,0,0,0,0,
              0,0,0,0,0), ncol = 5, byrow = T, dimnames = list(nam, nam))
sim <- c("sample(c(0,5,10),N, replace = T)", 
         rep("rnorm(N,BETA,1)",3), 
         "rpois(N, exp(BETA))")
model <- list(model = "glm", family = "poisson")
data <- sim_from_adj(G, n, sim)
summary(data)


# Analysis using the Environment Irrelevence test
class(model) <- "EnvirIrrel"
ICP(data$Y, data[,c("X1", "X2", "X3")], data$E, model = model, level = 0.05)


# Analysis using the old overlapping confidence rectangles test
class(model) <- "CRrectangle"
ICP(data$Y, data[,c("X1", "X2", "X3")], data$E, model = model, level = 0.05)

# Analysis using the new confidence regions test
class(model) <- "CRellipsoid"
ICP(data$Y, data[,c("X1", "X2","X3")], data$E, model = model, level = 0.05)

```


### Cox model

```{r}
n <- 500
nam <- c("E", "X1", "X2", "X3", "Y")
G <- matrix(c(0,1,1,1,0,
              0,0,0,0,0.4,
              0,0,0,0,0.4,
              0,0,0,0,0,
              0,0,0,0,0), ncol = 5, byrow = T, dimnames = list(nam, nam))
sim <- c("sample(c(0,5,10),N, replace = T)", rep("rnorm(N,BETA,1)",3), 
         "(-log(runif(N))/(0.0001*exp(BETA)))^(1/2.7)")
model <- list(model = "survival::coxph")
data <- sim_from_adj(G, n, sim)
summary(data)


# Analysis using the Environment Irrelevence test
class(model) <- "EnvirIrrel"
ICP(survival::Surv(data$Y), data[,c("X1", "X2", "X3")], data$E, model = model, level = 0.05)

# Analysis using the old overlapping confidence rectangles test
class(model) <- "CRrectangle"
ICP(survival::Surv(data$Y), data[,c("X1", "X2", "X3")], data$E, model = model, level = 0.05)

# Analysis using the new confidence regions test
class(model) <- "CRellipsoid"
ICP(survival::Surv(data$Y), data[,c("X1", "X2","X3")], data$E, model = model, level = 0.05)
```





Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
